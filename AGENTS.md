# AGENTS.md

This file provides context, rules, and instructions for AI agents working on the **Bassaleg Assessment Calendar** project. Adhere to these guidelines to ensure code quality, performance, and stability.

## 1. Project Overview

This is a React application built with Vite, TypeScript, and Tailwind CSS. It visualizes assessment timetables from Google Sheets data in two primary views: a **Monthly Calendar** and a **Linear Timeline**.

### Key Characteristics
-   **Dual Build**: The project is deployed as two separate instances (Year 10 and Year 11) from the same codebase, differing only by the source data URL.
-   **Static Data**: Data is fetched and processed at build time. The application reads data directly from `src/data.json`.
-   **Performance Focused**: The application is optimized for rendering potentially large schedules efficiently.

## 2. Key Technologies

*   **Framework**: React 18 with TypeScript
*   **Build Tool**: Vite
*   **Styling**: Tailwind CSS
*   **Unit Testing**: Vitest with React Testing Library
*   **E2E Testing**: Playwright
*   **Linting**: ESLint
*   **Data Parsing**: `exceljs` for parsing `.xlsx` files.

## 3. Critical Rules & Constraints

### ðŸ›‘ Strict Rules (Do Not Break)
1.  **Edit Source, Not Artifacts**: Never manually edit the `dist/` directory or the `src/data.json` file. The `data.json` file is generated by a script.
2.  **No Nested Components**: Never define a React component inside another component's function body. This causes unnecessary re-renders and hurts performance.
3.  **Window Mocking**: When testing code that interacts with `window.location` or `window.history`, you **must** use `Object.defineProperty` in Vitest to avoid errors on read-only properties.
4.  **Strict Linting**: The project enforces a `noUnusedLocals` rule. Your build **will** fail if you leave unused variables or imports. Run `npm run lint` often to check your code.

### ðŸŽ¨ UX & Accessibility
-   **Sticky Elements**: Sticky headers or banners must be nested within the main sticky container to ensure correct layer stacking. Avoid using manual `top` offsets.
-   **Filters**: Toggle buttons must use the `aria-pressed` attribute to properly communicate their state to screen readers.
-   **Past Events**: Visually de-emphasize past events (e.g., with 60% opacity), but ensure that text contrast remains accessible by keeping the text dark.
-   **Icons**: Use inline SVGs for icons. Do not add icon libraries like FontAwesome.

## 4. Architecture & Data Flow

### Data Pipeline
1.  **Source**: Data is managed by school staff in a Google Sheet.
2.  **Fetch Script**: The `scripts/download-and-parse.js` script downloads the Google Sheet as an XLSX file and parses it.
    -   **Input**: The script uses the URL from the `SHEET_URL` environment variable if it is set. Otherwise, it defaults to the URL in `scripts/year-10-sheet-url.txt`.
    -   **Output**: The script generates the `src/data.json` file.
3.  **Application**: The React application loads the data from `src/data.json`. For E2E tests, data is injected via `window.APP_DATA`.

### Multi-Year Deployment & CI/CD Pipeline
The deployment process is automated via a GitHub Actions workflow defined in `.github/workflows/deploy-timetables.yml`. This workflow deploys the site to GitHub Pages.

Key steps in the pipeline:
1.  **Trigger**: The workflow runs on a nightly schedule or on any push to the `main` branch.
2.  **Dual Build**: It performs two separate production builds:
    -   One for **Year 10**, using the data URL from `scripts/year-10-sheet-url.txt`.
    -   One for **Year 11**, using the data URL from `scripts/year-11-sheet-url.txt`.
3.  **Output**: Each build is placed into a subdirectory (`year-10/` and `year-11/`).
4.  **Landing Page**: A simple `index.html` is added to the root to provide links to both calendars.
5.  **Deploy**: The final directory containing both builds and the landing page is pushed to the `gh-pages` branch, which is then served by GitHub Pages.

To run a specific year's build locally, you can set the `SHEET_URL` environment variable before running the script:
```bash
SHEET_URL=$(cat scripts/year-11-sheet-url.txt)
node scripts/download-and-parse.js
```

## 5. Development Workflow

### Setup & Run
```bash
npm install # Install all dependencies
node scripts/download-and-parse.js  # Generate the necessary data.json file
npm run dev # Start the development server
```

### Verification Checklist
Before submitting any changes, run the following commands to ensure the project is in a good state:
1.  `npm run lint` - Checks for linting issues. You must fix all errors and warnings.
2.  `npm run typecheck` - Verifies TypeScript types. You must fix all reported issues.
3.  `npm run test` - Runs all unit tests. All tests must pass, and new features should have corresponding tests.
4.  `npm run test:coverage` - Reports unit test coverage. Aim to maintain or improve coverage.
5.  `npm run build` - Ensures the production build is successful.
6.  `npm run test:e2E` - Runs E2E smoke tests against the production build.
7.  `npm run preview` - Starts a local server to preview the production build.

## 6. Testing Strategy

### Unit Tests (Vitest)
-   **Mocking Data**: Use `vi.doMock` to mock the data from `src/data.json`. Remember to reset modules between tests.
-   **Dates**: For time-sensitive logic, use `vi.useFakeTimers({ toFake: ['Date'] })` to control the current date and avoid flaky tests.
-   **User Interaction**: Use `@testing-library/user-event` for simulating user interactions, as it provides a more realistic simulation than `fireEvent`.

### End-to-End (Playwright)
-   **Environment**: E2E tests run against a production build using the `preview` server.
-   **Data Injection**: Tests inject mock data using `window.APP_DATA` to ensure consistent test runs. See `e2e/smoke.spec.ts` for an example.
-   **Date Mocking**: Use `page.add_init_script` to mock the `Date` object if you are testing scenarios that depend on a specific date.

## 7. Coding Standards

### React & Performance
-   **Memoization**: The `TimelineView` component is computationally expensive and uses `React.memo`. When passing props (especially callbacks) to it, ensure they are stable by using `useCallback`.
-   **Loops**: Avoid nested loops with O(N*M) complexity in render functions. Use `Map` or `Set` for efficient data lookups inside loops.
-   **Date Handling**:
    -   Avoid calling `new Date()` inside loops.
    -   Use the utility functions in `src/utils/dateUtils.ts` for relative time calculations (e.g., "Today", "Yesterday").
    -   When handling ISO date strings, use substrings (the first 10 characters) to avoid timezone-related issues.

### Clean Code Principles

Adhere to the following principles to maintain a clean, readable, and maintainable codebase:

-   **Eliminate Duplication**: Identify and remove redundant code blocks, logic, or data structures. Abstract common patterns into reusable functions, hooks, or components.
-   **Refactor Continuously**: Don't be afraid to improve existing code. Small, incremental refactorings improve readability, maintainability, and performance over time.
-   **Decompose Functions**: Keep functions and components small, focused, and single-purpose. If a function is doing too many things, break it down into smaller, more manageable units.
-   **Meaningful Naming**: Use descriptive names for variables, functions, and components that clearly convey their purpose.
-   **Comments for 'Why'**: Add comments only when necessary to explain *why* a particular piece of code exists, *why* a certain decision was made, or to clarify complex business logic. Avoid comments that merely restate *what* the code is doing or *how* it works (these should be evident from the code itself).
-   **No "Thinking" Comments**: Do not leave comments in the codebase that describe your thought process, temporary debugging steps, or instructions to yourself (e.g., "TODO: fix this later," "Agent thought: I need to check X"). These must be removed before completing any task.

### File Structure
-   **Components**: Define components at the top level of their respective files.
-   **Tests**: Co-locate unit tests with the components they are testing (e.g., `Component.test.tsx`). E2E tests are located in the `e2e/` directory.

## 8. State Management

The application uses React's built-in hooks (`useState`, `useMemo`, `useCallback`) for state management. There is no external state management library like Redux or Zustand.

-   **`useData` Hook**: The core logic for data handling is encapsulated in the `src/hooks/useData.ts` custom hook. This hook is the single source of truth for assessment data and provides:
    -   The filtered schedule based on selected filters.
    -   Lists of all available subjects and assessment types.
    -   State variables (`selectedSubjects`, `selectedTypes`) and their setters.
-   **URL Syncing**: The `useData` hook also synchronizes the filter state with the browser's URL query parameters (e.g., `?lesson=math&type=exam`). This ensures that filtered views can be shared via URL. All filter state management should be handled within this hook.

## 9. UI & Component Philosophy

The UI is built using **Tailwind CSS** and custom React components.

-   **No Component Library**: The project does **not** use a third-party component library (like Material-UI, Ant Design, etc.).
-   **Utility-First**: All styling is done with Tailwind's utility classes. When creating new components, adhere to this utility-first approach.
-   **Custom Components**: All components are located in `src/components/` and are built from scratch. Before creating a new component, check if an existing one can be modified or reused.